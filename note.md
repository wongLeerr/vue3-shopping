### 配置@为src路径实现路径别名联想（新增jsconfig.json文件，实现配置）
### 按需引入element-plus，借助于两个插件，在项目中使用组件无需引入组件以及样式。
### element-puls 定制主题色
### 二次封装axios
### 配置路由, 默认二级路由的配置方式（设置path为空）
### 初始化样式个静态资源
### 安装插件errorlens，实时提示错误警告信息
### 配置scss文件的自动导入（在vite.config.js文件中配置），无需手工导入公共样式文件（存放一些共同的色值等变量）
### 页面结构搭建（以已给） 引入阿里图标库（font-class方式引入，应该是已经创建好了一个项目，有这个项目所需的全部图标，在index.html文件中引入此css样式（项目生成的），就可以在项目中使用i标签使用图标了）
### 实现一级导航的吸顶效果（下滑超过78px则实现自动吸顶） 使用vueUse插件获取滚动距离,使用动态类名:class的方式实现
### 注意切勿在组件中直接将 usexxxStore 调用得到的 store 进行解构属性（页面直接不生效），这样得到的属性不是响应式的，应该在得到的 store 由storeToRefs 处理得到的对象可以解构出响应式数据。
### 注意：在master分支改了很多内容，不进行add和commit，而是直接创建并切换到一个新的分支，会将改了的东西带到（剪切到）新分支，但master分支原先改的那些东西也没有了。
### 但是，如果在master分支改了很多东西，进行add和commit然后又创建其他分支并切换到新分支，这个新分支中会保持和master分支一样的状态，即 work tree clean，并且状态是master分支刚刚修改后的状态,在新分支push以后回到master分支发现又回到了一无所有的状态，还得从新分支上拉取代码。
### 封装面板组件（通过props和插槽传入可变部分）
### 自定义指令的实现
### 图片懒加载指令的实现（给图片需要懒加载的图片的绑定指令v-img-lazy,只有图片进入到视口区域时才会发送网络请求） ？ 难点：如何判断图片是否进行视口区域（使用vueUse插件） ？如何在检测到进入视口区域后发送网络请求获取图片资源通过给图片的url属性（img.url）属性赋予一个有效的地址即可自动实现发请求
### 自定义指令全部逻辑写在main.js中不合理，应将其抽象至专用文件夹directives，自定义指令应将其封装为一个插件（用到封装插件的语法，在main.js文件中引入，直接app.usexx即可）
### 优化：使用节流实现对vueUse进行某元素是否进入视口区域的重复监听。
### 配置路由，使得点击一级导航跳转到category页
### 如何实现一排a导航链接，实现点击哪项高亮哪项( 路由组件(router-link)有属性active-class )
### 解决路由缓存问题 对于带有参数的路由，比如从home页跳转到category页只是根据id不同展示不同页面，实则相同的组件被复用，这意味着切换路由时不会调用生命周期钩子，因此这种情景需要干掉路由缓存 （解决思路：1.干掉路由缓存，切换路由时进行销毁重建组件的动作（给router-view添加key属性，值为当前的完整路径，切换路由时完整路径发生变化，key变化，组件实例不被复用，于是销毁重建） 2.监听路由变化，路由发送变化执行数据更新操作(使用beforeRouteUpdate钩子，此钩子再每次路由切换之前执行，也就是说可以将切换路由后要发的网络请求放在这个里面)
### 使用逻辑函数拆分业务（抽离hook）
### 无限加载功能 （难点：何时请求要加载的数据，如何拼接） 解： 借助element-lus提供的无线滚动功能
### 常规问题：当在一个页面滚动一段距离后切换到另外一个页面后，这段滚动距离还在。解：这叫定制路由滚动行为（路由器中的方法，须在路由器中定制）
### 动态类 :class="{ active: activeIndex === i }" 当后面条件满足时给其加上active类
### 放大镜效果：1. 实现左侧阴影滑块跟随鼠标移动效果（获取鼠标再盒子内的相对位置（使用vueUse提供的useMouseInElement实现），滑块的移动通过控制其left值和top（监听elementX和elementY的变化，计算出left和top何时该变何时该锁死）） 2. 实现右侧大图放大效果（右图是背景图，盒子大小是固定的，通过控制背景图的方位来显示有效区域，左侧滑块向右移右侧滑块向左移，右侧显示大图是因为右侧本身的图片尺寸是左边的两倍，这意味着右图的移动距离为左侧的两倍） 3. 鼠标移入控制滑块和大图的隐藏(通过isOutSide控制)
### 注意，引入的第三方库或者插件，其里面的属性很有可能不是值本身而有可能是refImpl或者Proxy对象，要注意观察和打印。
### sku的概念，就是一群规格的集合，比如买衣服，大小、颜色、尺码、价格等等这些选中后要加入购物车的，加入购物车的这个选项集合就叫做sku
### components（src/components）文件夹下的组件是通用组件，有必要将其注册为全局组件，组件中无需引入，可直接使用，使用插件plugin解决这一问题
### 登录时用户名和密码表单数据是通过axios的body参数传递的，因此发请求时用的是data而不是params
### pinia 持久化（为了维持token的有效性）借助于pinia的插件,每个store中需要配置字段已决定该store是否需要持久化存储（是否需要pinia插件的超能力），该插件原理：点击登录，登录成功后返回userInfo，将此userInfo存储至localStorage中，当页面用到userInfo时，优先从localStoreage中取，即使刷新，虽然pinia中数据全无，但localStorage中数据还在并可更新pinia的空状态。
### 前端通过判断store中是否存在token来判断用户是否处于登录状态。
### 请求拦截器中携带token，在请求发出之前对请求参数做一些处理，通常将token注入请求header中，什么字段要跟后端协商
### 退出登录逻辑，清空用户信息（清空pinia中用户信息和localStorage中用户数据）,注意，在store中直接将userInfo清空同时插件也帮我们做到了清除localStorage的能力，因此可以理解store中的数据与localStorage中时刻保持同步
### 解决token失效（token存在生存时间限制） 401拦截处理（拿着失效的token去找服务器要数据就是401） 如何解决token失效：确定用户是在访问哪个接口时出现的401 && 如何拦截401错误（响应拦截器） 检测到401之后前端应该作何处理（token失效就是未登录状态了需要清空用户信息（这就是为啥强调何时检测出401的重要性，检测出401，立即执行清空信息的动作）并跳转到登录页）
### 购物车相关业务：
不登录能否操作购物车？ 可以，但不涉及接口，只是求助于pinia插件在localStorage中进行相关操作。
注意，在添加购物车时，比如买鞋，选择黑色38码和黑色39码会认为是不同的两个商品，会在购物车中当作两个商品展示，因此 在添加一条商品到购物车中时 判断该商品是否在购物车中判断的条件是skuId（不同的组合搭配会被认为是不同的商品）而不是id（只要是这个商品，无论何种搭配都算作是一条商品）

在购物车列表中标识每一件商品的是skuId而不是id(因为skuId是针对一件商品的不同搭配规格而生成的，而id就是指这件商品无论怎么搭配规格都是这个id，而在购物车中同一件商品的不同搭配规格是两件商品)

通过v-model绑定 obj.seleced 而obj是pinia中的数据，同样可以实现双向数据绑定，即实现view层数据修改穿透至pinia中

对于单选、多选框的实现，使用 v-model 未必最佳，如果将其回退到 v-model 的底层实现，那将是value和change事件的结合 （对于checkbox），那么将更好处理  

加入购物车
登录状态下加入购物车, (非登录先保存到本地-登录时再合并)

合并购物车

登录后需要把本地购物车合并，且清空本地购物车
退出登录时清空本地购物车列表，防止信息泄露

get请求在request请求中参数为params字段，post请求为data字段